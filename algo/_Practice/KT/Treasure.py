'''
Problem1 实现findLegalMoves()

findLegalMoves(board, start1[0], start1[1])
{0,  0,  0, -1, -1},
{0,  0, -1,  0,  0},
{0, -1,  0, -1,  0},
{0,  0, -1,  0,  0},
{0,  0,  0,  0,  0},
{0,  0,  0,  0,  0},
{0,  0,  0,  0,  0},

從一個點0，判斷是否能到另一個點0 

'''


'''
2. 实现boolean isReachable(int[][] board, int x, int y)
还是那个board，问能否到达所有的0

思路：從給定點做DFS，紀錄抵達的0個數，和所有0個數相比。
'''

'''
3. board3 中1代表钻石，给出起点和终点，问有没有一条不走回头路的路线，能从起点走到终点，并拿走所有的钻石，给出所有的最短路径。
board3 = [
    [  1,  0,  0, 0, 0 ],
    [  0, -1, -1, 0, 0 ],
    [  0, -1,  0, 1, 0 ],
    [ -1,  0,  0, 0, 0 ],
    [  0,  1, -1, 0, 0 ],
    [  0,  0,  0, 0, 0 ],
]
'''