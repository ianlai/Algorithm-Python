class Solution:


class Node():
    def __init__(self, ch = ""):
        self.char = ch
        self.charmap = {}
        self.isEnd = False
        
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = Node()

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self.root
        for ch in word:
            if ch in cur.charmap:
                cur = cur.charmap[ch]
            else:
                nextNode = Node(ch)
                cur.charmap[ch] = nextNode
                cur = nextNode
        cur.isEnd = True

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self.root
        for ch in word:
            if ch not in cur.charmap:
                return False
            cur = cur.charmap[ch]
        # if len(cur.charmap) != 0:
        return cur.isEnd
        
    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        cur = self.root
        for ch in prefix:
            if ch not in cur.charmap:
                return False
            cur = cur.charmap[ch]
        return True


# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
    
    
    # DFS + PrefixSet, check and add in the next layer, use string as cur (TLE)
    def findWords1(self, board: List[List[str]], words: List[str]) -> List[str]:
        if len(board) == 0 or len(board[0]) == 0 or len(words) == 0:
            return []
        
        m = len(board)
        n = len(board[0])
        prefixSet = set("")
        visited = [[0 for _ in range(n)] for _ in range(m)] 
        results = set()  #remove redundancies 
        
        #create prefixSet
        for word in words:
            for i in range(len(word) + 1):
                prefixSet.add(word[:i])
        #print(prefixSet)
        
        for i in range(m):
            for j in range(n):
                #print(board[i][j])
                visited[i][j] = 1
                self.dfs2(board, words, prefixSet, i, j, board[i][j], visited, results) #cur starts with board[i][j]
                visited[i][j] = 0  #backtracking 
        return list(results)
    
    def dfs2(self, board, words, prefixSet, i, j, cur, visited, results):
        curStr = "".join(cur)
        if curStr not in prefixSet:
            return 
        if curStr in words: 
            results.add(curStr)
            # keep searching
        
        m = len(board)
        n = len(board[0])
        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        # next 
        for d in dirs:
            nextI = i + d[0]
            nextJ = j + d[1]
            
            # current
            if not (0 <= nextI < m and 0 <= nextJ < n): #check the board 
                continue
            if visited[nextI][nextJ] == 1: #remove the redundancies
                continue        
            
            visited[nextI][nextJ] = 1
            nextWord = board[nextI][nextJ]
            #print(">>> ", nextI, nextJ, cur + nextWord)
            self.dfs2(board, words, prefixSet, nextI, nextJ, cur + nextWord, visited, results)  #concatanate the cur string 
            visited[nextI][nextJ] = 0         # backtracking

    # ===========================================
         
    # DFS + PrefixSet, check and add in the current layer, use list as cur (TLE)
    def findWords1(self, board: List[List[str]], words: List[str]) -> List[str]:
        if len(board) == 0 or len(board[0]) == 0 or len(words) == 0:
            return []
        
        m = len(board)
        n = len(board[0])
        prefixSet = set("")
        visited = [[0 for _ in range(n)] for _ in range(m)] 
        results = set()  #remove redundancies 
        
        #create prefixSet
        for word in words:
            for i in range(len(word) + 1):
                prefixSet.add(word[:i])
        print(prefixSet)
        
        for i in range(m):
            for j in range(n):
                self.dfs1(board, words, prefixSet, i, j, [], visited, results)
        return list(results)
    
    def dfs1(self, board, words, prefixSet, i, j, cur, visited, results):
        curStr = "".join(cur)
        if curStr not in prefixSet:
            return 
        if curStr in words: 
            results.add(curStr)
            # keep searching
        
        m = len(board)
        n = len(board[0])
        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        # current
        if not (0 <= i < m and 0 <= j < n): #check the board 
            return 
        if visited[i][j] == 1: #remove the redundancies
            return 
        cur.append(board[i][j])
        #print(curStr, cur)
        
        # next 
        visited[i][j] = 1
        for d in dirs:
            nextI = i + d[0]
            nextJ = j + d[1]
            self.dfs1(board, words, prefixSet, nextI, nextJ, cur, visited, results)
        
        # backtrack 
        visited[i][j] = 0
        cur.pop()